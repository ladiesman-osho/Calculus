package main

// Выше мы определили основной пакет программы. Для создания исполняемых файлов .exe пакет должен иметь имя main.
// Все остальные пакеты не являются исполняемыми.
// При этом пакет main должен содержать функцию main, которая является входной точкой в приложение.

// Далее импортируем стандартные пакеты Го.
import (
	"fmt"     // Пакет fmt реализует форматированный(?) ввод/вывод с помощью функций, аналогичных printf и scanf языка C.
	"strconv" // Пакет strconv реализует преобразования в строковые представления основных типов данных и обратно.
	"strings" // Пакет strings реализует простые функции для работы со строками в кодировке UTF-8.
)

// 1. Выходная точка в программу, главная функция любой программы на языке Го.
func main() {
	// 1.1 Ввод данных
	fmt.Println("Введите выражение от 1 до 10, без пробелов, можно использовать латинские символы I, II, ..., X:") // Выводим сообщение пользователю.
	var input string                                                                                               // Объявляем переменную и называем ее "input" для хранения введенного выражения. Тип данных - строка.
	fmt.Scanln(&input)                                                                                             // Считываем выражение с помощью функции Scanln.

	// 1.2 Вычисления
	result, err := calculate(input) // Вызываем функцию calculate c аргументом "input" для вычисления результата выражения. Сама функция написана ниже.
	if err != nil {                 // Если во время вычислений произошла ошибка,
		fmt.Println("Ошибка:", err) // то выводим сообщение об ошибке,
		return                      // и звершаем выполнение программы.
	}

	fmt.Println("Результат:", result) // Выводим результат вычислений.
}

// 2. Теперь напишем функцию для вычислений.
// 2.1 Функция "calculate" - вычисляет результат заданного выражения.
func calculate(input string) (int, error) {
	input = strings.ReplaceAll(input, " ", "") // Удаляем пробелы из строки выражения.

	operators := map[string]string{ // Создаем карту операторов.
		"+": "+",
		"-": "-",
		"*": "*",
		"/": "/",
	}

	// 2.2. Поиск оператора.
	var operator string         // Объявляем переменную для хранения оператора.
	for op := range operators { // Проверяем, какой оператор содержится в выражении.
		if strings.Contains(input, op) {
			operator = op // Находим оператор и сохраняем его.
			break
		}
	}

	if operator == "" { // Если оператор не найден,
		return 0, fmt.Errorf("оператор не поддерживается") // возвращаем ошибку.
	}

	// 2.3. Разделяем выражение на операнды с помощью оператора.
	operands := strings.Split(input, operator)
	if len(operands) != 2 { // Если количество операндов не равно 2,
		return 0, fmt.Errorf("неверное количество операндов") // возвращаем ошибку.
	}

	// 2.4 Выделяем оба операнда a и b
	a, err := parseOperand(operands[0]) // Парсим и сохраняем первый операнд. Функция написана ниже
	if err != nil {
		return 0, err // Если произошла ошибка, возвращаем ее.
	}

	b, err := parseOperand(operands[1]) // Парсим и сохраняем второй операнд. Функция написана ниже
	if err != nil {
		return 0, err // Если произошла ошибка, возвращаем ее.
	}

	// 2.5 Выполняем арифмитическую операцию в зависимости от оператора.
	switch operator {
	case "+":
		return a + b, nil
	case "-":
		return a - b, nil
	case "*":
		return a * b, nil
	case "/":
		if b == 0 {
			return 0, fmt.Errorf("деление на ноль")
		}
		return a / b, nil
	default: // Если оператор не поддерживается, возвращаем ошибку
		return 0, fmt.Errorf("неверный операция")
	}
}

// 3. Функция "parseOperand" - преобразует операнд из строки в целое число.
func parseOperand(operand string) (int, error) {
	if isRomanNumeral(operand) { // Функция написана ниже. Если операнд - римское число,
		value, err := romanToArabic(operand) // то преобразуем римское число в арабское(int).
		if err != nil {                      // Если произошла ошибка,
			return 0, fmt.Errorf("неверный римский числовой формат") // то возвращаем ее.
		}
		return value, nil // Возвращаем преобразованное число.
	} else { // Если операнд - арабское число,
		value, err := strconv.Atoi(operand)        // то, преобразуем строку в число(int).
		if err != nil || value < 1 || value > 10 { // Если произошла ошибка или число не в диапазоне 1-10,
			return 0, fmt.Errorf("неверный арабский числовой формат") // то возвращаем ошибку.
		}
		return value, nil // Возвращаем преобразованное число.
	}
}

// 4. Функция "isRomanNumeral" - проверяет, является ли строка римским числом.
func isRomanNumeral(input string) bool {
	romanNumerals := []string{"I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X"} // Создаем список римских чисел.

	// Проверяем, содержится ли входная строка в списке римских чисел.
	for _, numeral := range romanNumerals {
		if strings.Contains(input, numeral) { // если,
			return true
		}
	}
	return false
}

// 5. Функция "romanToArabic" - преобразует римское число в арабское.
func romanToArabic(input string) (int, error) {
	romanNumerals := map[string]int{ // Создаем карту римских чисел.
		"I":    1,
		"II":   2,
		"III":  3,
		"IV":   4,
		"V":    5,
		"VI":   6,
		"VII":  7,
		"VIII": 8,
		"IX":   9,
		"X":    10,
	}

	result := 0        // Инициализируем переменную для хранения результата.
	previousValue := 0 // Инициализируем переменную для хранения предыдущего значения.

	// Проходим по строке числа справа налево.
	for i := len(input) - 1; i >= 0; i-- {
		value := romanNumerals[string(input[i])] // Получаем значение текущего символа.

		if value < previousValue { // Если значение символа меньше предыдущего значения.
			result -= value // Вычитаем текущее значение из результата.
		} else { // Иначе,
			result += value       // прибавляем текущее значение к результату.
			previousValue = value // Обновляем предыдущее значение.
		}
	}

	return result, nil // Возвращаем результат преобразования римского числа
}
