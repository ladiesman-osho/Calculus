package main

import (
	"bufio"   // Пакет реализует буферизованный ввод-вывод.
	"fmt"     // Пакет реализует форматированный ввод и вывод.
	"os"      // Пакет предоставляет платформонезависимый интерфейс к функциональности операционной системы.
	"strings" // Пакет реализует функции для манипуляции со строками.
)

/*
Исправить:
1. Некорректно выводится ответ для римских выражений, например, вместо XL выводится XXXX
2. Не выбрасывается исключение при вводе чисел меньше 1 или больше 10
*/

/* Выше мы определили основной пакет программы. Для создания исполняемых файлов - ".exe" пакет должен иметь имя "main".
Все остальные пакеты не являются исполняемыми. При этом пакет main должен содержать функцию main, которая является
входной точкой в приложение.

Также мы загрузили необзодимые для работы программы пакеты*/

// Основная функция программы.
func main() {
	// Создаем новый читатель для чтения данных из стандартного ввода.
	reader := bufio.NewReader(os.Stdin)

	// Запрашиваем ввод от пользователя.
	fmt.Print("Введите выражение: ")

	// Читаем строку из стандартного ввода, пока не встретим символ новой строки.
	input, _ := reader.ReadString('\n')

	// Вычисляем результат выражения при помощи функции calculate
	result, err := calculate(input)
	if err != nil {
		// Если произошла ошибка, выводим ее сообщение.
		fmt.Println("Ошибка:", err)
		// Иначе выводим результат.
	} else {
		fmt.Println("Результат:", result)
	}
}

// Функция calculate принимает строку выражения и возвращает его результат и ошибку (если есть).
/*
В данном коде представлена реализация функции, которая принимает на вход строку с арифметическим выражением в виде
"число_1 оператор число_2" и возвращает результат вычисления этого выражения.
*/
func calculate(input string) (string, error) {
	expression := strings.ReplaceAll(input, " ", "") // Удаляем пробелы из строки выражения.
	operators := []string{"+", "-", "*", "/"}        // Создаем список допустимых операторов.

	// Разбиение строки на опертор и числа (int), конвертация в арабский формат для вычислений и возврат числа в римский формат при необходимости.
	for _, operator := range operators {
		parts := strings.Split(expression, operator) // Разделяем выражение на две части по оператору.
		if len(parts) == 2 {                         // Если оператор найден и выражение успешно разделено на две части.
			a := strings.TrimSpace(parts[0]) // Удаляем пробелы с обоих концов первой части выражения.
			b := strings.TrimSpace(parts[1]) // Удаляем пробелы с обоих концов второй части выражения.

			// Проверка диапозона вводимых чисел
			if isOutOfRange(a) || isOutOfRange(b) {
				return "", fmt.Errorf("число(-ла) вне диапазона 1-10 или ввведены не корректные числа")
			}

			// Если первая часть выражения является арабским числом.
			if isArabic(a) {
				// Если вторая часть выражения также является арабским числом.
				if isArabic(b) {
					// оба числа арабские
					aInt := 0 // создаем переменную для первого числа.
					bInt := 0 // создаем переменную для второго числа.
					// Преобразуем первую часть выражения в целое число.
					_, err := fmt.Sscanf(a, "%d", &aInt)
					if err != nil {
						// Возвращаем ошибку, если первая часть выражения не может быть преобразована в число.
						return "", fmt.Errorf("некорректное число: %s", a)
					}
					// Преобразуем вторую часть выражения в целое число.
					_, err = fmt.Sscanf(b, "%d", &bInt)
					if err != nil {
						// Возвращаем ошибку, если вторая часть выражения не может быть преобразована в число.
						return "", fmt.Errorf("некорректное число: %s", b)
					}

					// Выполняем соответствующую арифметическую операцию и возвращаем результат.
					switch operator {
					case "+":
						// Возвращаем результат сложения двух чисел.
						return fmt.Sprintf("%d", aInt+bInt), nil
					case "-":
						// Возвращаем результат вычитания двух чисел.
						return fmt.Sprintf("%d", aInt-bInt), nil
					case "*":
						// Возвращаем результат умножения двух чисел.
						return fmt.Sprintf("%d", aInt*bInt), nil
					case "/":
						if bInt == 0 {
							// Возвращаем ошибку, если второе число равно нулю.
							return "", fmt.Errorf("деление на ноль")
						}
						// Возвращаем результат деления двух чисел.
						return fmt.Sprintf("%d", aInt/bInt), nil
					}
				} else {
					// Возвращаем ошибку, если вторая часть выражения не является арабским числом.
					return "", fmt.Errorf("числа разных систем счисления или ввведены не корректные числа")
				}
				// Если первая часть выражения является римским числом.
			} else if isRoman(a) {
				// Если вторая часть выражения также является римским числом.
				if isRoman(b) {
					// Оба числа римские.
					aInt, err := toArabic(a) // Преобразуем первую часть выражения в арабское число.
					if err != nil {
						// Возвращаем ошибку, если первая часть выражения не может быть преобразована в арабское число.
						return "", err
					}
					bInt, err := toArabic(b) // Преобразуем вторую часть выражения в арабское число.
					if err != nil {
						// Возвращаем ошибку, если вторая часть выражения не может быть преобразована в арабское число.
						return "", err
					}

					// Выполняем соответствующую арифметическую операцию над арабскими числами и преобразуем результат обратно в римское число.
					switch operator {

					case "+":
						result := aInt + bInt
						romanResult, err := toRoman(result) // тут вызывается функция преобразования в арабское число.
						if err != nil {
							// Возвращаем ошибку, если результат не может быть преобразован в римское число.
							return "", err
						}
						// Возвращаем результат в виде римского числа.
						return romanResult, nil

					case "-":
						result := aInt - bInt
						if result <= 0 {
							// Возвращаем ошибку, если результат отрицательный или равен нулю.
							return "", fmt.Errorf("в римской системе нет отрицательных чисел")
						}
						romanResult, err := toRoman(result)
						if err != nil {
							// Возвращаем ошибку, если результат не может быть преобразован в римское число.
							return "", err
						}
						// Возвращаем результат в виде римского числа.
						return romanResult, nil

					case "*":
						result := aInt * bInt
						romanResult, err := toRoman(result)
						if err != nil {
							// Возвращаем ошибку, если результат не может быть преобразован в римское число.
							return "", err
						}
						// Возвращаем результат в виде римского числа.
						return romanResult, nil

					case "/":
						if bInt == 0 {
							// Возвращаем ошибку, если второе число равно нулю.
							return "", fmt.Errorf("деление на ноль")
						}
						result := aInt / bInt
						romanResult, err := toRoman(result)
						if err != nil {
							// Возвращаем ошибку, если результат не может быть преобразован в римское число.
							return "", err
						}
						// Возвращаем результат в виде римского числа.
						return romanResult, nil
					}
				} else {
					// Возвращаем ошибку, если вторая часть выражения не является римским числом.
					return "", fmt.Errorf("числа разных систем счисления или ввведены не корректные числа")
				}
			} else {
				// Возвращаем ошибку, если первая часть выражения не является ни арабским, ни римским числом.
				return "", fmt.Errorf("числа разных систем счисления или ввведены не корректные числа")
			}
		}
	}
	// Возвращаем ошибку, если оператор не найден или выражение не может быть разделено на две части.
	return "", fmt.Errorf("некорректное выражение")
}

// Функция isOutOfRange проверяет диапозон вводимых чисел.
func isOutOfRange(s string) bool {
	if isArabic(s) {
		var n int
		_, _ = fmt.Sscanf(s, "%d", &n)
		return n < 1 || n > 10
	}
	return false
}

// Функция isArabic проверяет, является ли переданная строка арабским числом.
func isArabic(s string) bool {
	_, err := fmt.Sscanf(s, "%d", new(int))
	return err == nil
}

// Функция isRoman проверяет, является ли переданная строка римским числом.
func isRoman(s string) bool {
	// Создаем список римских чисел от 1 до 10.
	romanNumerals := []string{"I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X"}
	for _, numeral := range romanNumerals {
		// Если переданная строка совпадает с одним из римских чисел, возвращаем true.
		if s == numeral {
			return true
		}
	}
	// Если переданная строка не является римским числом, возвращаем false.
	return false
}

// Функция toArabic преобразует римское число в арабское число.
func toArabic(s string) (int, error) {
	// Список римских чисел от 1 до 10.
	romanNumerals := []string{"I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X"}
	// Соответствующие арабские числа.
	arabicNumerals := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	for i, numeral := range romanNumerals {
		// Если переданное римское число совпадает с одним из списка,
		if s == numeral {
			// то возвращаем соответствующее арабское число.
			return arabicNumerals[i], nil
		}
	}
	// Если переданное римское число не найдено в списке, возвращаем ошибку.
	return 0, fmt.Errorf("некорректное римское число")
}

// Функция toRoman преобразует арабское число в римское число.
/*
Функция toRoman преобразует арабское число в римское число. Алгоритм преобразования основан на пошаговом вычитании
значения символов римской записи из исходного числа.
*/
func toRoman(number int) (string, error) {
	// Вводим переменную для возврата в будуюущем приобразованного числа.
	result := ""
	/*
		Затем, в цикле, происходит перебор символов римской записи в порядке убывания их значения. Каждый символ
		представлен структурой, содержащей значение символа и сам символ. Например, символ "C" представлен значением 100.
	*/
	for _, symbol := range []struct {
		Value  int
		Symbol string
	}{
		{100, "C"},
		{90, "XC"},
		{80, "LXXX"},
		{70, "LXX"},
		{60, "LX"},
		{50, "L"},
		{40, "XL"},
		{30, "XXX"},
		{10, "X"},
		{9, "IX"},
		{5, "V"},
		{4, "IV"},
		{1, "I"},
	} { /*
			Внутри цикла проверяется, является ли значение "number" большим или равным значению символа. Если это так,
			символ добавляется к строке "result", а значение "number" уменьшается на значение символа. Таким образом, мы
			"вычитаем" символ из исходного числа.
		*/
		for number >= symbol.Value {
			result += symbol.Symbol
			number -= symbol.Value
		}
		/*
			После завершения цикла исходное число "number" становится равным нулю, и возвращается строка "result",
			содержащая римскую запись числа.
		*/
	}

	return result, nil // Возвращаем результат преобразования в случае успеха или "nil" в качестве ошибки.
}

/*
Исправить:
1. Некорректно выводится ответ для римских выражений, например, вместо XL выводится XXXX
2. Не выбрасывается исключение при вводе чисел меньше 1 или больше 10
*/
